#==============================================================================#
#                                                                              # 
#      Software Register wrapper and simulation model                          # 
#                                                                              # 
#      Module name: sw_reg_r_wrapper                                           # 
#      Desc: wraps the verilog sw_reg_r and provides a model for simulation    # 
#      Date: Jan 2012                                                          # 
#      Developer: Wesley New                                                   # 
#      Licence: GNU General Public License ver 3                               # 
#      Notes:                                                                  # 
#                                                                              # 
#==============================================================================#

from myhdl import *

class sw_reg_r:

   def __init__(self, module_name, interrupt, wb_data_width = 32, wb_addr_width = 1):
      self._bus_interface = "wishbone"    # static parameter, "none", "wishbone", "epb"
      self._wb_mem_addrs  = "1"           # static paramter,  memory requirements for this module, 1 addr = 32bits
      self.module_name    = module_name   # the name of the module
      self.has_interrupt  = interrupt     # set in the module form 0 = no, 1 = yes
      self.WB_DATA_WIDTH  = wb_data_width # set in the module form
      self.WB_ADDR_WIDTH  = wb_addr_width # set in the module form
      self.WB_BASE_ADDR   = "0"           # base address, this is generated by bus management
      self.WB_HIGH_ADDR   = "0"           # high address, this is generated by bus management

   def sw_reg_r_wrapper(self,
         #===============
         # fabric ports
         #===============
         fabric_clk,
         fabric_data_in,
   
         #============
         # wb inputs
         #============
         wb_clk_i,
         wb_rst_i,
         wb_cyc_i,
         wb_stb_i,
         wb_we_i ,
         wb_sel_i,
         wb_adr_i,
         wb_dat_i,
                 
         #=============
         # wb outputs
         #=============
         wb_dat_o,
         wb_ack_o,
         wb_err_o

         #=============
         # Parameters
         #=============
         #BASEADDR      = 0,
         #HIGHADDR      = 32,
         #WB_DATA_WIDTH = 32,
         #WB_ADDR_WIDTH = 1,
         #BYTE_EN_WIDTH = 4
      ):
   
      #========================
      # TODO:Simulation Logic
      #========================
      @always(wb_clk_i.posedge)
      def logic():
         temp = 1
      
      # removes warning when converting to hdl
      fabric_data_in.driven = "wire"
      wb_dat_o.driven       = "wire"
      wb_ack_o.driven       = "wire"
      wb_err_o.driven       = "wire"
   
      return logic
  

   #========================
   # Counter Instantiation
   #========================
   # as an attribute on the wrapper function
   sw_reg_r_wrapper.verilog_code = \
   """
   sw_reg_r
   #(
      .C_BASEADDR      (%(self.WB_BUS_BASE_ADDR)s), 
      .C_HIGHADDR      (%(self.WB_BUS_HIGH_ADDR)s), 
      .C_WB_DATA_WIDTH (%(self.WB_DATA_WIDTH)s), 
      .C_WB_ADDR_WIDTH (%(self.WB_ADDR_WIDTH)s) 
   ) sw_reg_r_%(module_name)s (
     
      .fabric_clk     (%(fabric_clk)s),
      .fabric_data_in (%(fabric_data_in)s),
                                       
      .wb_clk_i       (%(wb_clk_i)s),
      .wb_rst_i       (%(wb_rst_i)s),
      .wb_cyc_i       (%(wb_cyc_i)s),
      .wb_stb_i       (%(wb_stb_i)s),
      .wb_we_i        (%(wb_we_i)s),
      .wb_sel_i       (%(wb_sel_i)s),
      .wb_adr_i       (%(wb_adr_i)s),
      .wb_dat_i       (%(wb_dat_i)s),

      .wb_dat_o       (%(wb_dat_o)s),
      .wb_ack_o       (%(wb_ack_o)s),
      .wb_err_o       (%(wb_err_o)s)
   );
   """


#=======================================
# For testing of conversion to verilog
#=======================================
def convert():

   x = sw_reg_r(module_name="sw_reg1", interrupt = "0")
   fabric_clk,fabric_data_in, wb_clk_i, wb_rst_i, wb_cyc_i, wb_stb_i, wb_we_i, wb_sel_i, wb_adr_i, wb_dat_i, wb_dat_o, wb_ack_o, wb_err_o = [Signal(bool(0)) for i in range(13)]

   toVerilog(x.sw_reg_r_wrapper, fabric_clk=fabric_clk, fabric_data_in=fabric_data_in, wb_clk_i=wb_clk_i, wb_rst_i=wb_rst_i, wb_cyc_i=wb_cyc_i, wb_stb_i=wb_stb_i, wb_we_i=wb_we_i, wb_sel_i=wb_sel_i, wb_adr_i=wb_adr_i, wb_dat_i=wb_dat_i, wb_dat_o=wb_dat_o, wb_ack_o=wb_ack_o, wb_err_o=wb_err_o)
   

if __name__ == "__main__":
   convert()
   
